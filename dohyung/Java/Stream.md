## 1. Stream

스트림을 이용하면 선언형으로 컬렉션 데이터를 처리할 수 있다.  
선언형이란 데이터를 처리하는 구현 코드 대신, 질의로 표현하는 것이다.  
또한 멀티 스레드로 구현하지 않아도 데이터를 투명하게 병렬적으로 수행할 수 있다.

### 1-1. 특징

### 파이프라이닝

대부분의 스트림 연산은 스트림 연산끼리 커다란 파이프라인을 구성하기 위해 자신을 반환한다.  
덕분에 laziness, short-circuiting 등과 같은 최적화를 얻을 수 있다.

### 내부 반복

반복자를 이용해서 명시적으로 반복하는 컬렉션과 달리 스트림은 내부 반복을 지원한다.

### 1-2. 탐색과 연산

### 탐색
```java
List<String> list = Arrays.asList("a", "b", "c");
Stream<String> s = list.stream();
s.forEach(System.out::println);
s.forEach(System.out::println); // 이미 스트림이 소비되어서 사용할 수 없다.
```

스트림은 이터레이터와 마찬가지로 한 번만 탐색할 수 있다.  
다시 말해 탐색된 스트림 요소는 소비된다.  
재탐색하려면 초기 데이터 소스로 새로운 스트림을 만들어야 한다.

### 연산

filter, map 등과 같은 중간 연산은 스트림을 반환한다.  
따라서 여러 중간 연산을 연결해서 질의를 만들 수 있다.  
스트림은 중간 연산을 합친 다음에 합쳐진 중간 연산을 최종 연산으로 한 번에 처리한다.  
스트림 파이프라인에 실행하기 전까지는 아무 연산도 수행하지 않아서 lazy하다.

최종 연산은 스트림 파이프라인에서 결과를 도출한다.  
최종 연산에 의해 List, Integer, void 등 스트림 이외의 결과를 반환한다.

> `Stream`과 `Collection`  
> 가장 큰 차이는 데이터를 언제 계산하느냐이다.  
> 
> 컬렉션은 현재 자료구조가 포함하는 데이터를 메모리에 저장한다.  
> 그래서 포함되는 모든 데이터는 컬렉션에 추가되기 전에 계산되어야 한다.  
> 
> 반면 스트림은 요청할 때만 요소를 계산하는 고정된 자료구조이다.  
> 스트림에 요소를 추가하거나 제거할 수 없기 때문에 고정된 자료구조라고 표현한다.  
> 
> 또 컬렉션은 사용자가 직접 요소를 반복하는 외부 반복이지만, 스트림은 내부 반복으로 처리한다.