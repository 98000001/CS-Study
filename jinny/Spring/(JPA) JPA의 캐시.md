## 1차 캐시
영속성 컨텍스트 내부에는 엔티티를 보관하는 저장소
트랜잭션을 시작하고 종료할 때까지만 1차 캐시가 유효
데이터베이스 접근 횟수를 획기적으로 줄이지는 못함

## 2차 캐시(공유캐시)
2차 캐시는 애플리케이션을 종료할 때까지 유지
분산 캐시나 클러스터링 환경의 캐시는 애플리케이션보다 더 오래 유지
2차 캐시를 적용하면 em를 통해 데이터를 조회할 때 우선 2차 캐시에서 찾고 없으면 DB에서 찾는다

영속성 컨텍스트(1차 캐시) -> 2차 캐시 -> DB 조회
if 2차 캐시 존재 -> 엔티티 복사 반환
2차 캐시는 데이터베이스 기본 키를 기준으로 캐시하지만 영속성 컨텍스트가 다르면 객체 동일성 (a == b)을 보장 X

### 2차 캐시 장점
같은 객체를 동시에 수정하는 문제가 발생 -> 락을 걸면 성능 및 동시성이 떨어짐
2차캐시는 동시성을 극대화 하기 위해 캐시 한 객체를 직접 반환하지 않고 복사본을 만들어 반환
객체에 락을 걸면 동시성이 떨어짐 -> 복사가 저렴
2차 캐시는 애플리케이션 범위의 캐시이므로 데이터베이스 조회가 1차 캐시만 사용할 때 보다 획기적으로 줄어듬

spring.jpa.properties.hibernate.cache.use_second_level_cache = true
// 2차 캐시 활성화합니다.

spring.jpa.properties.hibernate.cache.region.factory_class
// 2차 캐시를 처리할 클래스를 지정합니다.

spring.jpa.properties.hibernate.generate_statistics = true
// 하이버네이트가 여러 통계정보를 출력하게 해주는데 캐시 적용 여부를 확인할 수 있습니다.
@Cacheable
