## 영속성 컨텍스트 
ORM은 객체와 데이터베이스 테이블의 매핑을 통해 엔티티 클래스 객체 안에 포함된 정보를 테이블에 저장하는 기술

엔티티의 생명주기

<img width="689" alt="image" src="https://github.com/98000001/CS-Study/assets/96863137/c6aa18f2-f47f-4f49-a6cb-d0cd71d07345">

비영속(new/transient) : 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태
영속(managed) : 영속성 컨텍스트에 관리되는 상태
준영속(detached) : 영속성 컨텍스트에 저장되었다가 분리된 상태
삭제(remove) : 삭제된 상태

영속석 컨텍스트 영역
<img width="505" alt="image" src="https://github.com/98000001/CS-Study/assets/96863137/b5215f78-e39d-4dcf-8a97-9948af329282">
1차 캐시 영역과 쓰기 지연 SQL 저장소 영역

### 영속성 상태의 장점
- 1차 캐시
JPA API 중에서 엔티티 정보를 영속성 컨텍스트에 저장하는 API를 사용하면, 영속성 컨텍스트의 1차 캐시에 엔티티 정보가 저장됨
영속성 컨텍스트에 저장된 데이터나 데이터베이스에 저장된 데이터를 조회 -> em.find()
find() 메서드는 먼저 영속성 컨텍스트의 1차 캐시에 조회할 엔티티가 존재하는지 탐색 ->
만약, 1차 캐시에 존재하지 않을 경우 데이터베이스에서 조회한 뒤, 1차 캐시에 저장->
이후 조회 데이터를 반환
+ 같은 데이터를 2번 조회할 경우 조회 쿼리는 1회만 실행된다.

- 동일성(identity) 보장
동일한 Entity를 조회하면, 같은 주소값을 보장하기 때문에 == 비교시, true가 반환 됨
-> 1차 캐시에 Entity가 존재하기 때문에 가능
-> 1차 캐시로 반복 가능한 읽기(REPEATABLE READ) 등급의 트랜잭션 격리 수준을 데이터베이스가 아닌 애플리케이션 차원에서 제공

- 트랜잭션을 지원하는 쓰기 지연
em.persist(); : 엔티티를 영속 컨텍스트에 저장하지만, 데이터베이스에는 반영되지 않음
tx.commit(); : 트랜잭션을 커밋하는 순간 데이터베이스에 INSERT SQL을 보내 저장
영속 컨텍스트의 1차 캐시에는 엔티티가 저장 ->
쓰기 지연 SQL 저장소에는 엔티티의 INSERT SQL 쿼리문이 저장 ->
txcommit()을 실행하는 순간 쓰기 지연 SQL 저장소에 저장된 INSERT SQL 쿼리를 보내 데이터베이스에 저장

- 변경 감지
엔티티의 수정은 set메서드를 통해서 변경한 뒤, 별다른 로직 없이 트랜잭션 커밋을 하는 순간에 업데이트
-> 트랜잭션 커밋 시 flush()가 발생하면서 1차 캐시에서 엔티티와 스냅샷을 비교하여 변경에 대한 감지
SQL UPDATE 쿼리를 생성하여 쓰기 지연 SQL 저장소에서 쿼리를 보냄
이로써 DB에 저장된 데이터를 수정

- 지연 로딩
프록시, 즉시 로딩, 지연 로딩
