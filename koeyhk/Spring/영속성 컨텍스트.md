# 영속성 컨텍스트

### 구조

- 1차 캐시 저장소 : 영속성 컨테그스가 관리하는 엔티티 정보를 보관하는 장소로, 1차캐시에 저장되면 해당 엔티티는 영속상태가 됨 (영속 상태는 DB에 저장된 상태가 아님)
- 쿼리문 저장소 : 필요한 쿼리문을 보관해두게 되는데 나중에 저장된 쿼리문을 DB로 접근하는 행위를 flush() 메소드를 통해 수행

<img src="https://github.com/98000001/CS-Study/assets/80199502/c6ec704d-fa36-45a3-a267-7bb525f9d2d8"  width="600">

## 특징

### 1차 캐시

- 엔티티를 저장하거나 조회하는 경우에 1차 캐시에 저장되며 캐시에 저장된 데이터를 가져옴
<img src="https://github.com/98000001/CS-Study/assets/80199502/29700675-9898-4562-84a3-95275386cbab"  width="600">

- 1차 캐시내에 데이터가 없는 경우에는 DB에서 엔티티를 가져오기 위해 Select 쿼리를 수행하여 가져옴
<img src="https://github.com/98000001/CS-Study/assets/80199502/9cf3ca17-6b65-4743-8ee6-a7443f5ccf4e"  width="600">
  
<br>

### 동일성 보장

- JPA의 경우 '1차 캐시'에서 엔티티를 조회하므로 동일한 객체를 반환
<img src="https://github.com/98000001/CS-Study/assets/80199502/9d360fa5-20a4-4feb-b6ab-844f2d3a26ca"  width="600">

<br>

### 트랜잭션을 지원하는 쓰기지연

- 쓰기지연 SQL 저장소에 있는 모아진 쿼리를 엔티티 매니저가 commit() 메소드를 호출하면 한꺼번에 DB로 보내게 되는 것
- 쿼리를 모아 두었다가 한 번에 DB로 보내기 때문에 불필요한 리소스 낭비가 없어 성능을 높일 수 있음
- commit() 메소드의 경우 내부에 flush 작업이 포함되어 있음

<br>

### 변경 감지(Dirty Checking)

- 1차 캐시에 존재하는 엔티티에 대해 setter를 이용하여 값을 수정하면 자동으로 UPDATE가 발생
- 엔티티 매니저에는 update는 없는데 그 이유가 변경감지 기능을 통해 Update 하기 때문
- JPA는 엔티티를 1차 캐시에 저장할 때, 최초 상태를 복사해서 저장하는데 이를 스냅샷 기능이라고 함
- flush() 메소드 호출 후 스냅샷과 실제 엔티티를 비교하고 복사본과 실제 넘어온 엔티티가 다르다면 변경을 감지하고 Update문을 생성하여 쿼리문을 실행

<img src="https://github.com/98000001/CS-Study/assets/80199502/6a25ac1e-95b1-405a-afc9-08fcba454496"  width="600">

<br>

### 지연 로딩(lazy loading)
- 쿼리로 요청한 데이터를 애플리케이션에 바로 로딩하지 않고 필요할 때 쿼리를 날려 데이터를 조회하는 특징

<br><br><br><br><br>

참고 자료: <br>
https://yarisong.tistory.com/29
