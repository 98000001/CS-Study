# 객체지향

### 객체 지향 프로그래밍

- ~~컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나~~ 여러개의 독립된 단위, 즉 ‘객체’ 들의 모임으로 파악하고자 하는 것.
- 각각의 객체는 메시지를 주고 받고 데이터를 처리할 수 있다 (협력)
- 프로그램을 **유연하고 변경에 용이하게** 만들기 때문에 대규모 소프트웨어 개발에 많이 쓰임
    - 컴포넌트를 쉽고 유연하게 변경하면서 개발 할 수 있는 방법

### 상속

- 기존 클래스에 기능을 추가하거나 재정의하여 새로운 클래스를 정의한다
- 상속의 장점
    - 코드를 재사용 할 수 있다
        - 하위 클래스는 상위 클래스의 메소드나 필드를 이용할 수 있다 ( 접근 제한자 이용 )
    - 다형성 구현
- 상속의 단점
    - 상위 클래스에 강하게 결합한다
        - 상위 클래스와 강하게 결합하여 응집력이 낮아져 수동적인 객체가 된다
        - 상위 클래스의 메소드를 오버라이딩 하면 캡슐화가 깨진다 ..?
        - 즉, 상속은 추상 클래스와 인터페이스로 구현해야한다
            - 추상 클래스나 인터페이스는 추상 메소드가 조잰하며, 하위 클래스에서 해당 추상 메소드를 재정의 해야한다. 추상 메소드는 불완전한 것이고, 하위 클래스가 불완전한 것을 재정의 하며 완전한 것으로 탈바꿈한다.
            - 인스턴스 필드는 되도록 private 으로 설정할 것
            - 이미 정의된 메소드를 재정의 하지 말 것.
            - 클래스 상속의 경우 ‘is-a’ 관계인지 확인할 것

### 다형성

- 인터페이스를 구현한 객체 인스턴스를 실행 시점에 **유연하게 변경**할 수 있다.
- 클라이언트를 변경하지 않고, 서버의 구현 기능을 **유연하게 변경**할 수 있다.
- 역할(인터페이스)과 구현 (인터페이스를 구현한 클래스, 구현 객체)으로 구분
    - 역할과 구현으로 구분하면 세상이 단순해지고 유연해지며 변경이 편리해진다
        - 클라이언트는 대상의 역할만 알면 된다
        - 클라이언트는 구현 대상의 내부 구조를 몰라도 된다
        - 클라이언트는 구현 대상의 내부 구조가 변경되어도 영향을 받지 않는다
        - 클라이언트는 구현 대상 자체를 변경해도 영향을 받지 않는다.
    - 객체 설계시 역할(인터페이스) 를 먼저 부여하고 그 역할을 수행하는 구현 객체 만들기!
- 오버라이딩
    - 다형성으로 인터페이스를 구현한 객체를 실행시점에 유연하게 변경할 수 있다.
- 스프링과 객체지향
    - 다형성이 가장 중요하다
    - 스프링은 다형성을 극대화하여 이용할 수 있게 해준다
    - 스프링의 IoC, DI는 다형성을 활용해 역할과 구현을 편하게 다룰 수 있도록 한다
    - 

### 캡슐화

- 실제 구현 내용 일부를 외부에 감추는!

### 좋은 객체 지향 설계의 5가지 원칙(SOLID)

- SRP: 단일 책임 원칙(single responsibility principle)
    - 한 클래스는 하나의 책임만 가져야한다
    - 중요한 기준은 변경이다. 변경이 있을 때 파급 효과가 적으면 단일 책임 원칙을 따른 것
- OCP: 개방-폐쇄 원칙 (Open/closed principle)
    - 확장에는 열려 있으나 변경에는 닫혀있어야한다.
    - 다형성을 활용하여 인터페이스를 구현한 새로운 클래스(확장)를 만들어 새로운 기능을 구현(확장)한다
- LSP: 리스코프 치환 원칙 (Liskov substitution principle)
    - 프로그램의 객체는 프로그램 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야한다
- ISP: 인터페이스 분리 원칙 (Interface segregation principle)
    - 특정 클라이언트를 위한 인터페이스 여러개가 범용 인터페이스 하나보다 낫다
    - 분리하면 인터페이스가 명확해지고, 대체 가능성이 높아진다
- DIP: 의존관계 역전 원칙 (Dependency inversion principle)
    - 추상화에 의존해야지, 구체화에 의존하면 안된다.
    - 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻

## 클린 코드 일부 ..

### 캡슐화

- 변수와 유틸리티 함수는 가능한 공개하지 않는 편이 낫지만 반드시 숨겨한다는 법칙도 없다
- 때로는 변수나 유틸리티 함수를 protected 로 선언해 테스트 코드에 접근을 허용해도 된다. 같은 패키지 안에서 테스트 코드가 함수를 호출하거나 변수를 사용해야 한다면 그 함수나 변수를 protected로 선언하거나 패키지 전체로 공개한다.

### 클래스

```jsx
class Main{
	public static 상수
	private static 변수
	private 변수
	// public 변수가 필요한 일은 거의 없다

	/**
		* 공개 함수
	**/
	/**
		* 비공개 함수 (자신을 호출하는 공개 함수 직후)
	**/
}
```

1. 클래스는 작아야한다. 클래스는 더 작아야한다
2. 클래스 이름은 책임을 기술해야한다.
    1. 단일 책임 원칙 (SRP)
        1. 클래스나 모듈을 변경할 이유가 단 하나뿐이어야 한다.
        2. 변경할 이유를 파악하려 하다보면 코드를 추상화하기도 쉬워진다
3. 큰 클래스 몇개가 아니라 작은 클래스 여럿으로 이뤄진 시스템이 바람직하다 .. 

### 응집도

- 응집도가 높다는 말은 클래스에 속한 메소드와 변수가 서로 의존하며 논리적인 단위로 묶인다. 는 말이다
- 응집도를 유지하면 작은 클래스 여럿이 나온다
- 그치만 .. 클래스가 응집력을 잃는다면 쪼개라 ..!