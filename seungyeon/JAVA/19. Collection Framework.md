# 19. Collection Framework(List, Map, Set 등)

| List | 순서 유지, 저장, 중복 저장 O | ArrayList,Vector, Stack,LinkedList |
| --- | --- | --- |
| Set | 순서 유지, 저장, 중복 저장 X | Hashset, TreeSet |
| Map | 키와 값을 쌍으로 저장, 순서 유지 불가능, 키 중복 저장 불가능 | HashMap,Hashtable ,TreeMap, Properties |

### List<E>

- 순서가 있고 데이터 중복이 허용
- 크기가 가변적이며 비어있는 데이터가 없음
- 원하는 데이터가 뒤쪽에 있을 경우 속도가 떨어짐

### **ArrayList**

- 데이터를 배열에서 관리하며 추가,삭제를 위해 임시 배열을 생성해 데이터를 복사함.
- 추가/삭제마다 배열을 새로 만들어 복사하므로 참조보다 추가,삭제가 많을 경우 불리
- Array와 ArrayList의 차이
    - Array는 길이 고정. ArrayList는 Array를 이용해 만든 List형 자료구조.
    - ArrayList는 배열을 이용해 리스트를 구현. 배열을 가변적으로 사용하며 List의 특성인 저장 순서 유지와 중복 허용을 가지고 있음.
    - ArrayList는 클래스이기 때문에 배열 추가/삭제 기능도 포함

### **LinkedList**

- 데이터를 저장하는 각 노드가 이전 노드와 다음 노드의 상태를 가지고 있음
- 내부적으로 양방향 연결리스트로 구성되어 원소를 순방향, 역방향으로 순회 가능
- 데이터 참조는 배열에 비해 시간이 오래걸림

**ArrayList와 LinkedList**

| 컬렉션 | 읽기(접근시간) | 추가/삭제 | 비고 |
| --- | --- | --- | --- |
| ArrayList | 빠르다 | 느리다 | 순차적 추가삭제는 더 빠르다. 메모리를 비효율적으로 쓴다. |
| LinkedList | 느리다 | 빠르다 | 데이터가 많을수록 접근성 떨어진다. |

### Set<E>

- 저장된 순서를 유지하지 않고, 중복된 데이터를 허용하지 않음.

### **HashSet**

- 순서 없이 저장, 중복된 요소 불가
- 객체를 저장하기 전에 객체의 hashcode 메소드를 호출해 해시값을 얻고 이미 저장되어있는 객체 해시 코드와 비교

### LinkedHashSet

- HashSet 과 동일하지만 입력된 순서를 저장하고 관리

### **TreeSet**

- 오름차순으로 데이터를 저장하고 관리
- Red-Black Tree( 이진 검색 트리 )형태로 데이터를 저장
    - Red-Black Tree
        - 자가 균형 이진 탐색 트리
        - 모든 노드는 빨간색 || 검은색 / 루트 노드,리프 노드는 검정색
        - 빨간 노드의 자식은 검은색 (빨간 노드가 연속으로 나올 수 없음)
        - 모든 리프 노드에서 black depth 는 같음(리프노드에서 루트 노드까지 가는 경로에서 만나는 검은색 노드 개수가 같음)
    - 이진 검색 트리
        - 이진 검색트리는 한 노드에 2개의 노드를 연결할 수 있음.
        - 부모 노드로부터 오른쪽으로 확장된 자식 노드는 부모 노드의 값보다 커야함.
        - 왼쪽으로 확장된 자식 노드는 부모 노드 값보다 작아야함
        - 이진 검색 트리는 정렬과 검색에 특화되어있음. 비 순차적으로 저장하기 때문에 노드 추가, 삭제에 시간이 걸림.

### Map<K,V>

- Key-Value로 이루어진 데이터 집합
- key에 대한 중복이 없으며, 순서를 보장하지 않음
- 빠른 검색 속도 O(1)
- 인덱스가 따로 존재하지 않음
- Entry라는 내부 클래스를 정의하고 다시 Entry 타입의 배열을 선언. key-value 는 연관된 값이기에 하나의 클래스 내에서 하나의 배열로 다뤄 데이터 무결성을 지킴.
- 기본 타입을 사용할 수 없고 클래스 타입과 인터페이스 타입만 가능.
- key-value를 쌍으로 저장하기 때문에 iterator()를 호출 할 수 없음. 따라서 keySet(),entrySet() 과 같은 메소드로 Set으로 변환한 후 iterator 호출 가능

### HashMap

- HashMap은 내부적으로 배열을 만들어 관리, key 값으로 넘겨준 객체의 해시 코드를 계산하여 배열의 접근 인덱스로 사용
- Hashtable과 HashMap은 Vector와 ArrayList의 관계와 같아서 새로운 버전인 HashMap 사용을 권장
    - ArrayList는 기존의 Vector를 개선하여서 구현원리나 기능이 비슷한데, Vector는 기존 소스와의 호환성을 위해 남겨 두고 있는 것이기 때문에 웬만하면 ArrayList를 사용하는 것이 권장
    - HashMap은 키와 값에 null 허용, HashTable은 허용하지 않음
    - 가장 큰 차이는 Thread-safe
        - HashTable의 모든 데이터 변경 메소드는 sycronized로 선언되어있음. 메소드 호출 전 스레드 간 동기화 락을 통해 멀티 스레드 환경에서 데이터의 무결성을 보장.
        - HashMap은 Thread-safe 하지 않기때문에 멀티 스레드 환경에서 동시에 데이터를 조작하는 경우 데이터가 깨질 수 있음
        - 동기화가 필요하다면, ConcurrentHashMap 사용. HashTable은 구형버전이기에 HashMap에 비해 느림.

### TreeMap

- key-value 쌍을 내부적으로 RedBlack Tree로 저장하여 관리.
- O(log n)
- 정렬된 순서 보장

### LinkedHashMap

- 데이터 입력 순서 기억
- O(1) 이지만 Linked-List를 유지하기 위한 비용이 발생함