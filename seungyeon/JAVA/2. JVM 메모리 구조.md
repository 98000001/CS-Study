# JVM 메모리 구조

### JVM 이란?

- 자바와 운영체제 사이에서 중개자 역할 수행.
- 자바가 운영체제에 구애받지 않고 프로그램 실행 할 수 있도록 도와줌
- 가비지 컬렉터를 이용해 메모리 관리를 수행함
- 레지스터 기반이 아닌 스택 기반으로 동작함
- JVM 은 운영체제에 종속적. JAVA가 운영체제와 플랫폼에 의존적이지 않고 독립적으로 실행할 수 있도록 함

### 자바 프로그램 실행 단계

- 자바 소스 파일은 자바 컴파일러에 의해 바이트 코드 형태인 클래스 파일이 됨. 이 클래스 파일은 클래스 로더가 읽어들이며 JVM 이 수행됨
- **Java Compiler**
    - 자바 소스 파일을 바이트 코드로 변환함
- **Class Loader**
    - JVM으로 클래스 파일을 로드하고 링크를 통해 배치하는 작업을 수행
    - 런타임시에 동적으로 클래스를 로드
- **Execution Engine**
    - Class Loader를 통해 Runtime Data Area에 배치된 바이트 코드들을 명령어 단위로 읽어서 실행
    - 인터프리터 + JIT 컴파일러 방식으로 진행.
        - JIT : 바이트 코드를 어셈블러 같은 네이티브 코드로 바꿔 실행. 빠르지만 변환하는데 비용 발생
        - 따라서, 모든 코드를 JIT 방식으로 실행하지 않고 인터프리터 방식을 사용하다가 일정 기준이 넘어가면 JIT 방식으로 실행
- **Garbage Collector**
    - Heap 메모리 영역에 생성된 객체들 중에서 참조되지 않은 객체들을 탐색 후 제거함
        - Stack Area, Method Area도 GC 의 대상
    - 객체의 생존 여부를 판단하여 더이상 참조되지 않거나 null 인 객체의 메모리를 반납함
    - GC 가 역할을 하는 시간은 언제인지 정확히 모름
- **Runtime Data Area**
    - JVM 메모리 영역으로 자바 애플리케이션이 실행하며 할당받은 메모리 영역
    - **Method Area** : 모든 스레드가 공유하는 메모리 영역. **클래스, 인터페이스, 메소드, 필드 static 변수** 등의 바이트 코드 보관
    - **Heap Area** : 모든 스레드가 공유하며 **new 키워드로 생성된 객체와 배열**이 생성되는 영역. 메소드 영역에 로드 된 클래스만 생성 가능함
        - 가비지 컬렉터가 참조되지 않는 메모리를 확인하고 제거하는 영역
    - **Stack Area** : 메소드 호출 시마다 각 스택 프레임(그 메소드를 위한 공간)이 생성함. **메소드 안에서 사용되는 값(지역변수?) 을 저장하고 호출된 메소드의 매개변수, 지역변수, 리턴 값 및 연산이 일어나는 값을 임시**로 저장. 마지막으로 메소드 수행이 끝나면 프레임별로 삭제
    - **PC Register** : 스레드가 시작될 때 생성되며 생성될 때 생성되는 공간으로 스레드마다 하나씩 존재. 스레드가 어떤 부분을 무슨 명령으로 실행해야할 지에 대한 기록을 하는 부분. 현재 수행중인 JVM 명령의 주소
    - **Native method stack** : 자바 외 언어로 작성 된 네이티브 코드를 위한 메모리 영역 (C/C++)