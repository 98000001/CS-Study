# Spring_interview.md

**Spring IoC,DI,AOP 에 대해 설명하세요**

→ IoC는 프로그램의 제어 흐름을 프레임워크에서 관리하는 것으로 코드의 최종 호출은 개발자가 제어하는 것이 아닌 프레임워크의 내부에서 결정된 대로 이루어진다

→ DI는 Spring 프레임워크에서 지원하는 IoC의 형태로, 객체 간 의존 관계를 빈 설정 정보를 바탕으로 컨테이너가 자동으로 연결해준다.

→ AOP 는 관심사를 분리하여 공통의 관심사를 모듈화 하여 제공하는 프로그래밍 방법으로 트랜잭션, 보안, 인증 등이 공통 모듈의 대상이 된다.

**DI 주입 방법 차이**

→ 생성자 주입, 필드 주입, 세터 주입이 있는데 그 중 생성자 주입을 권장한다. 생성자 주입은 순환 참조를 방지할 수 있고, 불변성을 보장하며 테스트에 용이하다는 장점이 있다.

**Bean 생명 주기**

→ Spring Bean 의 생명 주기는 `생성 → 의존 설정 → 초기화 → 사용 → 소멸`이다. 이것은 스프링 컨테이너에 의해 관리되며 등록시에는 컴포넌트 스캔을 이용하거나 빈 설정파일에 직접 빈을 등록하면 된다. 초기화 시에는 PostConstruct, 빈 소멸에는 PreDestroy 를 사용하면 된다.

**Spring 필터와 인터셉터의 차이**

→ 필터는 Dispatcher Servlet에 요청이 전달되기 전/후에 url 패턴에 맞는 모든 요청에 대해 부가 작업을 처리할 수 있음. 스프링 컨테이너가 아닌 톰캣 같은 웹 컨테이너에 의해 관리. 스프링 범위 밖에서 처리. 스프링과 무관하게 전역적으로 처리해야하는 작업들

→ 인터셉터는 Dispatcher Servlet이 Controller를 호출하기 전/후에 인터셉터가 끼어들어 요청 응답을 참조하거나 가공할 수 있음. 스프링 컨텍스트에서 동작. 클라이언트 요청과 관련되어 전역적으로 처리해야하는 작업들

**영속성 컨텍스트의 장점**

→ 1차 캐시, 동일성 보장, 트랜잭션을 지원하는 쓰기 지연, 변경 감지, 지연 로딩

**즉시로딩과 지연로딩에 대해 설명해주세요**

→ 즉시 로딩은 데이터를 가져올 때 하나만 가져오는 것이 아닌 연관된 모든 객체의 데이터를 읽어오는 방식으로 조인으로 인한 성능 저하, N+1 문제가 발생할 수 있다.

→ 지연로딩은 연관된 객체는 프록시로 가져오지 않고 그 데이터가 필요할 때 가져오는 방식으로 연관된 엔티티의 쿼리가 분리되어 성능이 보다 좋다

**N+1 문제와 해결 방법에 대해 설명해주세요**

→ N+1 문제는 즉시로딩과 지연로딩 모두에서 발생할 수 있다. 즉시로딩에서는 연관된 모든 객체의 엔티티를 가져올 때 발생하고, 지연로딩에서는 프록시 객체의 데이터를 가져올 때 발생한다.

→ 이를 해결하기 위해서는 JPQL 의 fetch join 를 사용하거든 @EntityGraph를 사용하는 방법 등이 있다. 둘다 조인 조건을 명확히 하기에 해결하는 것이다.

**QueryDSL의 장점**

→ 컴파일 시점에 타입 안정성을 보장한다는 점. 객체 지향적인 쿼리를 작성할 수 있다는 점. 코드 가독성이 향상된다. 동적 쿼리가 가능하다.

**다대다 매핑의 문제점과 해결 전략**

→ RDB는 테이블 2개로 다대다 관계를 표현할 수 없기에, ORM에서 자동으로 연결 테이블을 생성하여 다대다 관계를 가능하게 해줌. 근데 이 자동으로 생성된 연결테이블에는 컬럼을 추가할 수없고 내부적으로 예상치 못한 쿼리가 발생하기에 성능 상 단점이 있음

→ 이를 해결하기 위해 중간 연결 테이블 엔티티를 추가해 일대다, 다대일 관계 두개로 풀어내야함