# 영속성 컨텍스트(캐시, 동일성보장, 변경감지, 트랜잭션 지연)

### 영속성 컨텍스트

ORM 은 객체와 DB 테이블의 매핑을 통해 엔티티 클래스 객체 안에 포함된 정보를 저장하는 기술

- 영속 : 영속성 컨텍스트에 관리되는 상태
- 준영속 : 영속성 컨텍스트에 저장되었다가 분리된 상태
- 삭제 : 삭제된 상태

### 영속성 상태의 장점

- 1차 캐시
    - 영속성 컨텍스트 내부의 1차 캐시.
    - 영속 상태의 엔티티를 이곳에 저장. 엔티티 조회 시 1차 캐시에 엔티티가 존재한다면 DB를 찾아보지 않아도 됨
- 동일성 보장
    - 1차 캐시로 트랜잭션 격리 수준을 DB가 아닌 애플리케이션 차원에서 제공해줄 수 있음
    - 성능상 이점과 엔티티 동일성 보장
- 트랜잭션을 지원하는 쓰기지연
    - em.persist() : 엔티티를 영속성 컨텍스트에 저장하지만 DB에 반영되지 않는다.
    - tx.commit() : 트랜잭션을 커밋하는 순간 DB에 INSERT SQL을 보내 저장한다
    - persist() 를 실행할 때 1차 캐시에 객체가 저장되고 쓰기지연 SQL 저장소에 INSERT SQL 이 저장된다.
    - commit() 실행하는 순간 쓰기지연 SQL 저장소에 저장된 쿼리를 보내 DB에 저장
    - 여러개의 엔티티를 생성하고 persist() 해도 commit() 하기전까지는 DB에 저장되지 않음. 이를 쓰기 지연이라고 하며, 영속성 컨텍스트의 장점.
- 변경 감지
    - 영속성 컨텍스트의 1차 캐시에 초기 데이터 저장. 이후 set 메소드로 데이터 변경.
    - commit() 시 flush() 발생하며 1차 캐시에서 엔티티와 스냅샷을 비교해 변경 감지.
    - 이후 UPDATE문 생성해 쓰기지연 SQL 저장소에서 쿼리 보냄
- 지연 로딩
    - 연관관계 매핑 되어있는 엔티티 조회시 우선 프록시 객체를 반환하고 실제 필요할 때 쿼리를 날려 가져오는 기능
    - 필요할 때 데이터를 가져오는 기능

### flush()

- 트랜잭션 커밋을 실행하면 변경 내용을 DB에 반영
- 트랜잭션 커밋이 일어날 때 flush 도 함께 발생하여 DB에 반영
- 영속성 컨텍스트의 변경 내용을 DB에 반영
- 영속성 컨텍스트의 변경 내용을 DB에 동기화 하는 역할
- 플러시는 트랜잭션이라는 작업 단위에 중요. commit() 직전에만 동기화하면 됨

**영속성 컨텍스트 플러시 하는 방법**

- em.flush() 직접 호출
- commit() 트랜잭션 커밋 통한 자동 호출
- JPQL 쿼리 실행 - flush 자동 호출
    - JPQL 실행 시 자동으로 flush 호출해 JPQL 쿼리를 반영할 수 있도록 함

출처 : https://ittrue.tistory.com/254